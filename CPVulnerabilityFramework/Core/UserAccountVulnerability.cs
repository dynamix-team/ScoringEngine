using System;
using System.Collections.Generic;
using System.DirectoryServices;
using System.DirectoryServices.AccountManagement;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security.Principal;

//REALLY ANNOYING MEMORY ISSUES WITH AD SERVICES

namespace CPVulnerabilityFramework.Core
{
    /// <summary>
    /// Base user account vulnerability class
    /// </summary>
    public class UserAccountVulnerability : Vulnerability, IDisposable
    {
        /// <summary>
        /// Types of account vulnerabilities
        /// </summary>
        public enum AccountVulnType
        {
            /// <summary>
            /// The user exists
            /// </summary>
            Add,
            /// <summary>
            /// The user doesnt exist
            /// </summary>
            Remove,
            /// <summary>
            /// The user is not locked out
            /// </summary>
            Enable,
            /// <summary>
            /// The user is disabled, not deleted
            /// </summary>
            Disable,
            /// <summary>
            /// The user's password expires
            /// </summary>
            PasswordExpires,
            /// <summary>
            /// The user's password never expires
            /// </summary>
            PasswordForever,
            /// <summary>
            /// The user has an expired password
            /// </summary>
            ForceExpirePassword,
            /// <summary>
            /// The user's password is encrypted
            /// </summary>
            DisableReversableEncryption,
            /// <summary>
            /// The user's password is changeable
            /// </summary>
            PasswordChangeable,
            /// <summary>
            /// The user's password cannot be changed
            /// </summary>
            PasswordImmutable,
            /// <summary>
            /// The user's account no longer expires
            /// </summary>
            StopAccountExpiring,
            /// <summary>
            /// The user's account is set to expire
            /// </summary>
            ExpireAccount,
            /// <summary>
            /// The user is no longer an administrator
            /// </summary>
            Demote,
            /// <summary>
            /// The user is now an administrator
            /// </summary>
            Promote,
            /// <summary>
            /// Unlock the user's account
            /// </summary>
            Unlock,
            /// <summary>
            /// The user is now part of a specific group
            /// </summary>
            AddGroup,
            /// <summary>
            /// The user is no longer part of a specific group
            /// </summary>
            RemoveGroup
        }

        private DirectoryEntry user;
        /// <summary>
        /// The user principle we are evaluating
        /// </summary>
        protected DirectoryEntry User
        {
            get
            {
                if (user == null)
                    try
                    {
                        foreach (DirectoryEntry childEntry in ComputerEntry.Children)
                            if (childEntry.SchemaClassName == "User" && childEntry.Name == UserName)
                                user = childEntry;
                            else
                                childEntry?.Dispose();
                        ComputerEntry?.Dispose();
                    }
                    catch
                    {
                    }
                return user;
            }
        }

        private readonly string ComputerPath = string.Format("WinNT://{0},computer", Environment.MachineName);
        private readonly DirectoryEntry ComputerEntry;

        /// <summary>
        /// The type of UserAccount Vulnerability
        /// </summary>
        protected AccountVulnType VulnType;
        /// <summary>
        /// The name of the user
        /// </summary>
        protected string UserName;

        /// <summary>
        /// A user account vulnerability
        /// </summary>
        /// <param name="points">Amount of points to give when complete</param>
        /// <param name="VulnType">A type of user account vulnerability</param>
        /// <param name="username">A case sensitive username</param>
        public UserAccountVulnerability(int points, AccountVulnType VulnType, string username) : base(points)
        {
            this.VulnType = VulnType;
            this.UserName = username;
            ComputerEntry = new DirectoryEntry(ComputerPath);
        }

        /// <summary>
        /// Internal use only
        /// </summary>
        public UserAccountVulnerability() : base()
        {

        }

        /// <summary>
        /// Dispose of this vulnerability object
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool v)
        {
            User?.Dispose();
            ComputerEntry.Dispose();
        }

        /// <summary>
        /// All possible flags for a win32 user account
        /// </summary>
        protected enum UserFlags : int
        {
            /// <summary>
            /// Uses script
            /// </summary>
            ADS_UF_SCRIPT = 1,
            /// <summary>
            /// Is the account disabled
            /// </summary>
            ADS_UF_ACCOUNTDISABLE = 2,
            /// <summary>
            /// Does this user require a home directory
            /// </summary>
            ADS_UF_HOMEDIR_REQUIRED = 8,
            /// <summary>
            /// Is this account locked out
            /// </summary>
            ADS_UF_LOCKOUT = 16,
            /// <summary>
            /// Does this account require a password
            /// </summary>
            ADS_UF_PASSWD_NOTREQD = 32,
            /// <summary>
            /// Can the user change their password
            /// </summary>
            ADS_UF_PASSWD_CANT_CHANGE = 64,
            /// <summary>
            /// Is reversible encryption allowed
            /// </summary>
            ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED = 128,
            /// <summary>
            /// Is this a temporary duplicate account
            /// </summary>
            ADS_UF_TEMP_DUPLICATE_ACCOUNT = 256,
            /// <summary>
            /// Is this a normal account
            /// </summary>
            ADS_UF_NORMAL_ACCOUNT = 512,
            /// <summary>
            /// Is this an interdomain trust account
            /// </summary>
            ADS_UF_INTERDOMAIN_TRUST_ACCOUNT = 2048,
            /// <summary>
            /// Is this a workstation trust account
            /// </summary>
            ADS_UF_WORKSTATION_TRUST_ACCOUNT = 4096,
            /// <summary>
            /// Is this a server trust account
            /// </summary>
            ADS_UF_SERVER_TRUST_ACCOUNT = 8192,
            /// <summary>
            /// Does this user's password expire
            /// </summary>
            ADS_UF_DONT_EXPIRE_PASSWD = 65536,
            /// <summary>
            /// Is this a MNS account
            /// </summary>
            ADS_UF_MNS_LOGON_ACCOUNT = 131072,
            /// <summary>
            /// Does this account require a smartcard
            /// </summary>
            ADS_UF_SMARTCARD_REQUIRED = 262144,
            /// <summary>
            /// Is this account trusted for delegation
            /// </summary>
            ADS_UF_TRUSTED_FOR_DELEGATION = 524288,
            /// <summary>
            /// Is this account not delegated
            /// </summary>
            ADS_UF_NOT_DELEGATED = 1048576,
            /// <summary>
            /// Does this account only use a DES key
            /// </summary>
            ADS_UF_USE_DES_KEY_ONLY = 2097152,
            /// <summary>
            /// Does this account not require preauth
            /// </summary>
            ADS_UF_DONT_REQUIRE_PREAUTH = 4194304,
            /// <summary>
            /// Has this account's password expired
            /// </summary>
            ADS_UF_PASSWORD_EXPIRED = 8388608,
            /// <summary>
            /// Do we trust this account for delegation
            /// </summary>
            ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION = 16777216,
        }

        /// <summary>
        /// Returns true if the user flag is set
        /// </summary>
        /// <param name="flag"></param>
        /// <exception cref="NullReferenceException">If the user doesnt exist</exception>
        /// <returns></returns>
        protected bool UserFlagSet(UserFlags flag)
        {
            if (User == null)
                throw new NullReferenceException();
            int value = (int)(User?.Properties["UserFlags"]?.Value ?? 0);
            return (value & (int)flag) == 1;
        }

        /// <summary>
        /// Does the current user have this group assigned to them
        /// </summary>
        /// <param name="groupname"></param>
        /// <exception cref="NullReferenceException">Thrown if the user is invalid</exception>
        /// <returns></returns>
        protected bool HasGroup(string groupname)
        {
            object obGroups = User.Invoke("Groups");
            bool found = false;
            foreach (object ob in (System.Collections.IEnumerable)obGroups)
            {
                DirectoryEntry obGpEntry = new DirectoryEntry(ob);
                if(obGpEntry.Name.ToLower() == groupname.ToLower())
                {
                    obGpEntry.Dispose();
                    found = true;
                    break;
                }
                obGpEntry.Dispose();
            }
            return found;
        }

        /// <summary>
        /// dont actually use
        /// </summary>
        protected override void EvaluateVulnerability()
        {
            Enabled = false; //in case some how this gets used?
        }

        /// <summary>
        /// Automatically pick the correct vulnerability based on the AccountVulnType
        /// </summary>
        /// <param name="args"></param>
        /// <returns></returns>
        public override Vulnerability TranslateArgs(params string[] args)
        {
            try
            {
                Enum.TryParse(args[1], true, out AccountVulnType vtype);
                switch(vtype)
                {
                    case AccountVulnType.PasswordForever:
                    case AccountVulnType.DisableReversableEncryption:
                    case AccountVulnType.PasswordChangeable:
                    case AccountVulnType.PasswordExpires:
                    case AccountVulnType.PasswordImmutable:
                    case AccountVulnType.ForceExpirePassword:
                        return new UA_PasswordVuln().TranslateArgs(args);
                    default:
                        return new UA_AccountAction().TranslateArgs(args);
                }
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// The delay between evaluations of a user account
        /// </summary>
        protected override long TickDelay => 5000;
    }
}
