using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace CPVulnerabilityFramework.Core
{
    /// <summary>
    /// A vulnerability to be checked
    /// </summary>
    public abstract class Vulnerability
    {

        #region typedef
        /// <summary>
        /// All defined types of vulnerabilities. You can add custom vulnerability definitions to this to allow them to be xml-auto parsed
        /// </summary>
        internal static readonly VulnerabilityDefinitions Types = new VulnerabilityDefinitions()
        {
            ["registry"] = typeof(RegistryMatchVulnerability),
            ["fileremoval"] = typeof(FileRemoveVulnerability),
            ["fileversion"] = typeof(FileVersionVulnerability),
            ["update"] = typeof(FileVersionVulnerability),
            ["forensic"] = typeof(ForensicsVulnerability),
            ["user"] = typeof(UserAccountVulnerability),
            ["firewall"] = typeof(FirewallVulnerability),
            ["passwordpolicy"] = typeof(PasswordPolicyVulnerability)

        };
        #endregion

        #region Fields
        /// <summary>
        /// The points to award/remove when a vulnerability state changes
        /// </summary>
        private readonly int pointvalue;

        /// <summary>
        /// The last time this instance was ticked
        /// </summary>
        private System.Diagnostics.Stopwatch ticker = new System.Diagnostics.Stopwatch();

        /// <summary>
        /// Can the vulnerability be undone?
        /// </summary>
        public bool RegressionEnabled = true;

        /// <summary>
        /// Is this vulnerability enabled
        /// </summary>
        public bool Enabled = true;
        
        /// <summary>
        /// Current point value of this vulnerability object
        /// </summary>
        public int Value
        {
            get
            {
                if (!Enabled) //If disabled, dont check us
                    return 0;

                if (Failed) //Check before, to save performance if we dont need to evaluate
                    return -1 * pointvalue;

                if (Completed && !RegressionEnabled) //If regression isnt enabled, why continue evaluating the vuln?
                    return pointvalue;
                
                if (ticker.ElapsedMilliseconds < TickDelay) //Only evaluate every Tick milliseconds
                {
                    return Completed ? pointvalue : 0;
                }

                ticker.Restart();
                OnCheckVulnerability?.Invoke(this, new VulnerabilityEventArgs());
                EvaluateVulnerability();

                if (Failed) //Check after to allow failure to occur on this evaluation frame
                    return -1 * pointvalue;
                return Completed ? pointvalue : 0;
            }
        }

        private bool __Completed__;
        /// <summary>
        /// If set to true, the vulnerability has been completed. If false, the vulnerability may still be active (unless it has failed)
        /// </summary>
        public bool Completed
        {
            get
            {
                if (Failed)
                    return false;
                return __Completed__;
            }
            set
            {
                if (value == __Completed__)
                    return;
                if (Failed)
                    return;
                if(value)
                {
                    OnCompleted?.Invoke(this, new VulnerabilityEventArgs());
                }
                else if(RegressionEnabled)
                {
                    OnRegressed?.Invoke(this, new VulnerabilityEventArgs());
                }
                else
                {
                    return; //Dont set the value if it is trying to regress when regression isnt enabled
                }
                __Completed__ = value;
            }
        }

        private bool __Failed__;

        /// <summary>
        /// If set to true, the vulnerability has failed irrecoverably and will no longer be scored
        /// </summary>
        public bool Failed
        {
            get
            {
                return __Failed__;
            }
            set
            {
                if (!__Failed__) //if we havent failed, set it to value
                {
                    __Failed__ = value;
                    OnFailed?.Invoke(this, new VulnerabilityEventArgs());
                }
            }
        }

        /// <summary>
        /// The message that describes the current state of the vulnerability
        /// </summary>
        public string Message = "";
        #endregion

        /// <summary>
        /// A scoring engine vulnerability
        /// </summary>
        public Vulnerability(int PointValue)
        {
            ticker.Start();
            pointvalue = PointValue;
        }

        /// <summary>
        /// Internal use only. All vulnerabilities contain a second definition with proper arguments
        /// </summary>
        public Vulnerability() 
        {
            Enabled = false;
            Failed = true; //So even if some knucklehead tries to use an empty vuln object, the vuln will never call evaluate
        }

        #region Events
        /// <summary>
        /// An event to fire in a vulnerability
        /// </summary>
        public delegate void VulnerabilityEvent(Vulnerability sender, VulnerabilityEventArgs e);


        private VulnerabilityEvent _oncompleted, _onregressed, _onfailed, _oncheckvuln;


        /// <summary>
        /// Fired when vulnerability conditions are met
        /// </summary>
        public VulnerabilityEvent OnCompleted
        {
            set
            {
                if (AssemblyLock)
                    return;
                _oncompleted = value;
            }
            get => _oncompleted;

        }

        /// <summary>
        /// Fired when vulnerability conditions were previously met, but are no longer met
        /// </summary>
        public VulnerabilityEvent OnRegressed
        {
            set
            {
                if (AssemblyLock)
                    return;
                _onregressed = value;
            }
            get => _onregressed;
        }

        /// <summary>
        /// Fired when the vulnerability has become impossible to complete
        /// </summary>
        public VulnerabilityEvent OnFailed
        {
            set
            {
                if (AssemblyLock)
                    return;
                _onfailed = value;
            }
            get => _onfailed;
        }

        /// <summary>
        /// Check a vulnerability for its completion state
        /// </summary>
        /// <returns></returns>
        public VulnerabilityEvent OnCheckVulnerability
        {
            set
            {
                if (AssemblyLock)
                    return;
                _oncheckvuln = value;
            }
            get => _oncheckvuln;
        }

        #endregion

        /// <summary>
        /// Evaluate the vulnerability
        /// </summary>
        protected abstract void EvaluateVulnerability();

        /// <summary>
        /// Create a vulnerability object from a list of string parameters
        /// </summary>
        /// <param name="args">Arguments</param>
        /// <returns></returns>
        public abstract Vulnerability TranslateArgs(params string[] args);

        /// <summary>
        /// Overrides the int implicit operator to allow for more convienient scoring
        /// </summary>
        /// <param name="v"></param>
        public static implicit operator int(Vulnerability v)
        {
            return v?.Value ?? 0;
        }

        /// <summary>
        /// Convert a string into a vulnerability
        /// </summary>
        /// <param name="node">The xml node to convert</param>
        public static implicit operator Vulnerability(XmlNode node) //todo: allow escaping the character '|'
        {
            //Literally the coolest idea I have ever had and it was such a pain to figure out :)
            try
            {
                Vulnerability v = ((Vulnerability)Activator.CreateInstance(Types[node.Name.ToLower()])).TranslateArgs(node.InnerText.Split('|'));
                return v;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Parses all available vulnerabilities from the document
        /// </summary>
        /// <param name="document">The document to parse</param>
        /// <returns></returns>
        public static List<Vulnerability> ParseVulnerabilities(XmlDocument document)
        {
            List<Vulnerability> vulns = new List<Vulnerability>();
            foreach(string key in Types.Keys)
            {
                foreach(XmlNode node in document.GetElementsByTagName(key))
                {
                    try
                    {
                        vulns.Add(node);
                    }
                    catch
                    {
                        //failed to add a vuln
                    }
                }
            }
            return vulns;
        }

        /// <summary>
        /// Add a custom type to the vulnerabilities list
        /// </summary>
        /// <param name="alias"></param>
        /// <param name="type"></param>
        /// <exception cref="AliasExistsException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public static void AddTypeAlias(string alias, Type type)
        {
            if (AssemblyLock)
                return;
            alias = alias.ToLower().Trim();
            if (!type.IsSubclassOf(typeof(Vulnerability)))
            {
                throw new ArgumentException("The type added must be of type 'Vulnerability'");
            }
            if(Types.ContainsKey(alias))
            {
                throw new CPVulnerabilityFramework.Core.AliasExistsException("The alias " + alias + " already has a type definition!");
            }
            Types[alias] = type;
        }

        /// <summary>
        /// This is the delay between evaluations that will occur before re-evaluating the state of the vulnerability
        /// </summary>
        protected virtual long TickDelay
        {
            get
            {
                return 1000;
            }
        }

        /// <summary>
        /// When set to true, all events are finalized
        /// </summary>
        private static bool AssemblyLock = false;

        /// <summary>
        /// Lock all customizable events, functions, and settings. Do not call until loading and customization is complete
        /// </summary>
        public static void LockAssembly()
        {
            AssemblyLock = true;
        }
    }

    #region Related classes
    /// <summary>
    /// Eventargs for a vulnerability object
    /// </summary>
    public sealed class VulnerabilityEventArgs : EventArgs
    {

    }

    /// <summary>
    /// A dictionary of vulnerability aliases along with their matching class
    /// </summary>
    [Serializable]
    public class VulnerabilityDefinitions : Dictionary<string, Type>
    {
        /// <summary>
        /// A vulnerabilities definition for custom vulnerabilities
        /// </summary>
        public VulnerabilityDefinitions():base()
        {

        }
        /// <summary>
        /// Visual studio made me do it
        /// </summary>
        /// <param name="info">info on the serialization</param>
        /// <param name="context">context of the serialization</param>
        protected VulnerabilityDefinitions(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) : base(info,context)
        {

        }
        /// <summary>
        /// Add a Vulnerability type to the dictionary
        /// </summary>
        /// <param name="alias">The alias of the vulnerability</param>
        /// <param name="type">The vulnerability</param>
        /// <exception cref="ArgumentException"></exception>
        public new void Add(string alias, Type type)
        {
            if(!type.IsSubclassOf(typeof(Vulnerability)))
            {
                throw new ArgumentException("The type added must be of type 'Vulnerability'");
            }
            base.Add(alias, type);
        }
    }
    #endregion

}
